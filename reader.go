package reader

import (
	"fmt"
	"strconv"
)

type Packet struct {
	Header []byte
	Data
}

type Data struct {
	SYN bool
	ACK bool
	RST bool
	FIN bool
	PSH bool
	URG bool
}

// SourcePort Source TCP port number (2 bytes or 16 bits):
// The source TCP port number represents the sending device.
func (p *Packet) SourcePort() (int64, error) {
	sp := fmt.Sprintf("%x", p.Header[0:2])

	output, err := strconv.ParseInt(sp, 16, 17)

	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// DestinationPort Destination TCP port number (2 bytes or 16 bits):
// The destination TCP port number is the communication endpoint for the receiving device.
func (p *Packet) DestinationPort() (int64, error) {
	dp := fmt.Sprintf("%x", p.Header[2:4])

	output, err := strconv.ParseInt(dp, 16, 17)

	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// SequenceNumber Sequence number (4 bytes or 32 bits):
// Message senders use sequence numbers to mark the ordering of a group of messages.
func (p *Packet) SequenceNumber() (int64, error) {
	sn := fmt.Sprintf("%x", p.Header[4:8])

	output, err := strconv.ParseInt(sn, 16, 33)
	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// AckNumber Acknowledgment number (4 bytes or 32 bits): Both senders and receivers
// use the acknowledgment numbers field to communicate the sequence numbers of
// messages that are either recently received or expected to be sent.
func (p *Packet) AckNumber() (int64, error) {
	an := fmt.Sprintf("%x", p.Header[8:12])

	output, err := strconv.ParseInt(an, 16, 33)
	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// DO TCP data offset (4 bits): The data offset field stores the total size of
// a TCP header in multiples of four bytes. A header not using the optional
// TCP field has a data offset of 5 (representing 20 bytes), while a header
// using the maximum-sized optional field has a data offset of 15 (representing 60 bytes).
func (p *Packet) DO() (int64, error) {
	do := fmt.Sprintf("%b", p.Header[12:14][0])
	output, err := strconv.ParseInt(do[0:4], 2, 5)

	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// RSV Reserved data (3 bits): Reserved data in TCP headers always has a value of zero.
// This field aligns the total header size as a multiple of four bytes,
// which is important for the efficiency of computer data processing.
func (p *Packet) RSV() (int64, error) {
	rs := fmt.Sprintf("%b", p.Header[12:14][0])
	output, err := strconv.ParseInt(rs[4:7], 2, 4)

	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// Flags Control flags (up to 9 bits): TCP uses a set of six standard and
// three extended control flags—each an individual bit representing On or Off—to manage
// data flow in specific situations.
func (p *Packet) Flags() (Data, error) {
	fg1 := fmt.Sprintf("%b", p.Header[12:14][0])
	fg2 := fmt.Sprintf("%b", p.Header[12:14][1])

	var data Data

	switch {
	case fg1[7:8] == "0":
		data.SYN = false
	default:
		data.SYN = true
	}

	switch {
	case fg2[0:1] == "0":
		data.ACK = false
	default:
		data.ACK = true
	}

	switch {
	case fg2[1:2] == "0":
		data.RST = false
	default:
		data.RST = true
	}

	switch {
	case fg2[2:3] == "0":
		data.FIN = false
	default:
		data.FIN = true
	}

	switch {
	case fg2[3:4] == "0":
		data.PSH = false
	default:
		data.PSH = true
	}

	switch {
	case fg2[4:5] == "0":
		data.URG = false
	default:
		data.URG = true
	}

	return data, nil
}

// Window Window size (2 bytes or 16 bits): TCP senders use a number,
// called window size, to regulate how much data they send to a receiver before
// requiring an acknowledgment in return. If the window size is too small,
// network data transfer is unnecessarily slow. If the window size is too large,
// the network link may become saturated,
// or the receiver may not be able to process incoming data quickly enough,
// resulting in slow performance. Windowing algorithms built into the protocol
// dynamically calculate size values and use this field of TCP headers to
// coordinate changes between senders and receivers.
func (p *Packet) Window() (int64, error) {
	w := fmt.Sprintf("%x", p.Header[14:16])

	output, err := strconv.ParseInt(w, 16, 33)
	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// Checksum TCP checksum (2 bytes or 16 bits): The checksum value inside
// a TCP header is generated by the protocol sender as a mathematical technique
// to help the receiver detect messages that are corrupted or tampered with.
func (p *Packet) Checksum() (int64, error) {
	chm := fmt.Sprintf("%x", p.Header[16:18])

	output, err := strconv.ParseInt(chm, 16, 33)
	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// UrgentPointer Urgent pointer (2 bytes or 16 bits): The urgent pointer field
// is often set to zero and ignored, but in conjunction with one of the control
// flags, it can be used as a data offset to mark a subset of a message as
// requiring priority processing.
func (p *Packet) UrgentPointer() (int64, error) {
	up := fmt.Sprintf("%x", p.Header[18:20])

	output, err := strconv.ParseInt(up, 16, 33)
	if err != nil {
		return -1, fmt.Errorf("got an error : %v", err)
	}

	return output, nil
}

// // Options TCP optional data (0 to 40 bytes): Usages of optional TCP data
// // include support for special acknowledgment and window scaling algorithms.
// func (p *Packet) Options() {
// 	fmt.Println("Options")
// }
